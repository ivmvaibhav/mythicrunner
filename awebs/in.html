<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mythic Runners: Journey of the Gods</title>
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: 'Merriweather', serif;
      text-align: center;
    }
    canvas {
      background: #222;
      border: 4px solid #FFC300;
      display: block;
      margin: 20px auto;
      box-shadow: 0 0 20px rgba(255, 87, 51, 0.8);
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1000" height="600"></canvas>
  <script>
    /* -------------------------
       Global Variables & Assets
       ------------------------- */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    let currentScreen = "menu"; // "menu", "options", "shop", "game"
    
    // Sound Effects
    const coinSound = new Audio("coin.mp3");
    const startSound = new Audio("start.mp3");
    const gameOverSound = new Audio("gameover.mp3");
    const jumpSound = new Audio("jump.mp3");
    const notSound = new Audio("not.mp3");
    let gameOverSoundPlayed = false;
    
    // Player Sprites
    const activeSprite = new Image();
    activeSprite.src = "cv1.png";
    const inactiveSprite = new Image();
    inactiveSprite.src = "cv2.png";
    
    // Coin Sprite Sheet
    const coinSprite = new Image();
    coinSprite.src = "coin.png";
    const coinFrameCount = 8;
    const coinFramesPerRow = 4;
    const coinFrameWidth = 38;
    const coinFrameHeight = 32;
    let coinSpriteFrame = 0;
    let coinFrameTimer = 0;
    const coinFrameInterval = 100;
    
    // Ground Obstacles
    const obstacleSprite0 = new Image();
    obstacleSprite0.src = "obj.png";
    const obstacleSprite1 = new Image();
    obstacleSprite1.src = "obj1.png";
    const obstacleSprite2 = new Image();
    obstacleSprite2.src = "obj2.png";
    
    // Lane ground positions
    const laneGround = [300, 599];
    
    /* -------------------------
       Game State Variables (for "game" screen)
       ------------------------- */
    let gameSpeed, gravity, score, coinsCollected, gameOver, paused, isGameStarted;
    // activeDimension: 0 = Deva (gods), 1 = Asura (demons)
    let activeDimension; 
    let obstacles, coins, obstacleTimer, obstacleInterval, coinTimer, coinInterval, lastTime;
    let totalCoins = 0;
    let highestScore = 0;
    let shopMessage = "";
    
    // For menu title animation
    let menuAnimationTime = 0;
    
    // Global animation frame ID
    let animationFrameId;
    
    /* -------------------------
       Constructors
       ------------------------- */
    
    function Player(lane) {
      this.lane = lane;
      this.x = 50;
      this.width = 80;
      this.height = 90;
      this.y = laneGround[lane] - this.height;
      this.yVelocity = 0;
      this.isJumping = false;
      this.jumpStrength = -16;
      this.color = lane === 0 ? "#FF4500" : "#FF8C00";
    }
    Player.prototype.update = function() {
      this.yVelocity += gravity;
      this.y += this.yVelocity;
      if (this.y + this.height > laneGround[this.lane]) {
        this.y = laneGround[this.lane] - this.height;
        this.yVelocity = 0;
        this.isJumping = false;
      }
    };
    Player.prototype.draw = function(isActive) {
      if (isActive && activeSprite.complete) {
        ctx.drawImage(activeSprite, this.x, this.y, this.width, this.height);
      } else if (!isActive && inactiveSprite.complete) {
        ctx.drawImage(inactiveSprite, this.x, this.y, this.width, this.height);
      } else {
        ctx.fillStyle = isActive ? this.color : "rgba(200,200,200,0.5)";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    };
    
    let playerA_game = new Player(0);
    let playerB_game = new Player(1);
    function getActivePlayer() {
      return activeDimension === 0 ? playerA_game : playerB_game;
    }
    function getInactivePlayer() {
      return activeDimension === 0 ? playerB_game : playerA_game;
    }
    
    function Obstacle(lane) {
      this.lane = lane;
      this.type = "ground";
      const sprites = [obstacleSprite0, obstacleSprite1, obstacleSprite2];
      this.sprite = sprites[Math.floor(Math.random() * sprites.length)];
      this.width = this.sprite.naturalWidth || 50;
      this.height = this.sprite.naturalHeight || 50;
      this.x = canvas.width;
      this.y = laneGround[lane] - this.height;
    }
    Obstacle.prototype.update = function() {
      this.x -= gameSpeed;
    };
    Obstacle.prototype.draw = function() {
      if (this.sprite.complete) {
        ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
      } else {
        ctx.fillStyle = "#f00";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    };
    
    function Coin(lane) {
      this.lane = lane;
      this.radius = 10;
      this.x = canvas.width;
      this.y = (laneGround[lane] - 25) - 10 + Math.random() * 10;
      this.color = "#FFD700";
    }
    Coin.prototype.update = function() {
      this.x -= gameSpeed;
    };
    Coin.prototype.draw = function() {
      if (coinSprite.complete) {
        const row = Math.floor(coinSpriteFrame / coinFramesPerRow);
        const col = coinSpriteFrame % coinFramesPerRow;
        ctx.drawImage(coinSprite,
          col * coinFrameWidth, row * coinFrameHeight,
          coinFrameWidth, coinFrameHeight,
          this.x, this.y, 20, 20);
      } else {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    };
    
    function initGame() {
      gameSpeed = 4;
      gravity = 0.7;
      score = 0;
      coinsCollected = 0;
      gameOver = false;
      paused = false;
      isGameStarted = false;
      obstacles = [];
      coins = [];
      obstacleTimer = 0;
      obstacleInterval = 1500;
      coinTimer = 0;
      coinInterval = 1200;
      lastTime = 0;
      playerA_game = new Player(0);
      playerB_game = new Player(1);
      activeDimension = 0;
      coinSpriteFrame = 0;
      coinFrameTimer = 0;
      gameOverSoundPlayed = false;
      menuAnimationTime = 0;
    }
    
    /* -------------------------
       Menu / Screen Drawing Functions
       ------------------------- */
    let currentMenuButtons = {};
    let currentOptionsButtons = {};
    let currentShopButtons = {};
    let skinPurchased = false;
    
    function drawMenu() {
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#FFD700";
      ctx.font = "16px Arial";
      ctx.fillText("Total Coins: " + totalCoins, 10, 20);
      ctx.fillText("Highest Score: " + highestScore, 10, 40);
      
      // Animated title with reset timer when coming back to menu
      menuAnimationTime += 16;
      let scale = 1 + 0.05 * Math.sin(menuAnimationTime / 500);
      ctx.save();
      ctx.translate(canvas.width / 2, 150);
      ctx.scale(scale, scale);
      ctx.fillStyle = "#FF5733";
      ctx.font = "50px Merriweather";
      let titleText = "Mythic Runners: Journey of the Gods";
      let textWidth = ctx.measureText(titleText).width;
      ctx.fillText(titleText, -textWidth / 2, 0);
      ctx.restore();
      
      const startBtn = { x: canvas.width / 2 - 150, y: 250, w: 300, h: 50, text: "Start Game" };
      const optionsBtn = { x: canvas.width / 2 - 150, y: 320, w: 300, h: 50, text: "Options" };
      const shopBtn = { x: canvas.width / 2 - 150, y: 390, w: 300, h: 50, text: "Divine Shop" };
      [startBtn, optionsBtn, shopBtn].forEach(btn => {
        ctx.fillStyle = "#444";
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = "#FFC300";
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        ctx.fillStyle = "#fff";
        ctx.font = "24px Merriweather";
        ctx.fillText(btn.text, btn.x + 50, btn.y + 32);
      });
      currentMenuButtons = { startBtn, optionsBtn, shopBtn };
    }
    
    function drawOptions() {
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      ctx.font = "40px Merriweather";
      ctx.fillText("Options", canvas.width / 2 - 70, 150);
      ctx.font = "24px Merriweather";
      ctx.fillText("Sound Volume: " + (startSound.volume * 100).toFixed(0), canvas.width / 2 - 100, 250);
      const volUp = { x: canvas.width / 2 - 150, y: 300, w: 120, h: 50, text: "Vol Up" };
      const volDown = { x: canvas.width / 2 + 30, y: 300, w: 120, h: 50, text: "Vol Down" };
      const backBtn = { x: canvas.width / 2 - 60, y: 380, w: 120, h: 50, text: "Back" };
      [volUp, volDown, backBtn].forEach(btn => {
        ctx.fillStyle = "#444";
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = "#FFC300";
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        ctx.fillStyle = "#fff";
        ctx.font = "20px Merriweather";
        ctx.fillText(btn.text, btn.x + 10, btn.y + 30);
      });
      currentOptionsButtons = { volUp, volDown, backBtn };
    }
    
    function drawShop() {
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#FFD700";
      ctx.font = "16px Arial";
      ctx.fillText("Total Coins: " + totalCoins, 10, 20);
      
      if (shopMessage) {
        ctx.fillStyle = "#fff";
        ctx.font = "20px Merriweather";
        let textWidth = ctx.measureText(shopMessage).width;
        ctx.fillText(shopMessage, canvas.width / 2 - textWidth / 2, 60);
      }
      
      ctx.fillStyle = "#fff";
      ctx.font = "40px Merriweather";
      ctx.fillText("Divine Shop", canvas.width / 2 - 70, 150);
      const shopItem = { x: canvas.width / 2 - 150, y: 250, w: 300, h: 50, text: "Buy Divine Attire (50 Coins)" };
      const backBtn = { x: canvas.width / 2 - 60, y: 330, w: 120, h: 50, text: "Back" };
      [shopItem, backBtn].forEach(btn => {
        ctx.fillStyle = "#444";
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = "#FFC300";
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        ctx.fillStyle = "#fff";
        ctx.font = "20px Merriweather";
        ctx.fillText(btn.text, btn.x + 10, btn.y + 30);
      });
      currentShopButtons = { shopItem, backBtn };
    }
    
    function drawGame(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      
      coinFrameTimer += deltaTime;
      if (coinFrameTimer > coinFrameInterval) {
        coinFrameTimer = 0;
        coinSpriteFrame = (coinSpriteFrame + 1) % coinFrameCount;
      }
      
      if (paused) {
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "40px Merriweather";
        ctx.fillText("Paused", canvas.width / 2 - 60, canvas.height / 2);
        return;
      }
      
      if (gameOver) {
        ctx.fillStyle = activeDimension === 0 ? "#87CEEB" : "#8B0000";  // Deva vs Asura
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (!gameOverSoundPlayed) {
          gameOverSound.play();
          gameOverSoundPlayed = true;
        }
        ctx.fillStyle = "#fff";
        ctx.font = "40px Merriweather";
        ctx.fillText("Game Over", canvas.width / 2 - 120, canvas.height / 2);
        return;
      }
      
      // In-game background
      ctx.fillStyle = activeDimension === 0 ? "#87CEEB" : "#8B0000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw lane divider (solid gold line)
      ctx.strokeStyle = "#FFC300";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, (laneGround[0] + laneGround[1]) / 2);
      ctx.lineTo(canvas.width, (laneGround[0] + laneGround[1]) / 2);
      ctx.stroke();
      
      obstacleTimer += deltaTime;
      if (obstacleTimer > obstacleInterval) {
        let lane = Math.random() < 0.5 ? 0 : 1;
        obstacles.push(new Obstacle(lane));
        obstacleTimer = 0;
      }
      coinTimer += deltaTime;
      if (coinTimer > coinInterval) {
        let lane = Math.random() < 0.5 ? 0 : 1;
        let candidateY, valid = false, attempts = 0;
        while (!valid && attempts < 10) {
          candidateY = (laneGround[lane] - 25) - 10 + Math.random() * 10;
          valid = true;
          for (let obs of obstacles) {
            if (obs.lane === lane && obs.x > canvas.width - 100) {
              if (candidateY < obs.y + obs.height && candidateY + 20 > obs.y) {
                valid = false;
                break;
              }
            }
          }
          attempts++;
        }
        if (valid) {
          let newCoin = new Coin(lane);
          newCoin.y = candidateY;
          coins.push(newCoin);
        }
        coinTimer = 0;
      }
      
      playerA_game.update();
      playerB_game.update();
      playerA_game.draw(activeDimension === 0);
      playerB_game.draw(activeDimension === 1);
      
      for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].update();
        obstacles[i].draw();
        const ap = getActivePlayer();
        const ip = getInactivePlayer();
        if (obstacles[i].lane === activeDimension &&
            ap.x < obstacles[i].x + obstacles[i].width &&
            ap.x + ap.width > obstacles[i].x &&
            ap.y < obstacles[i].y + obstacles[i].height &&
            ap.y + ap.height > obstacles[i].y) {
          gameOver = true;
        }
        if (obstacles[i].lane !== activeDimension &&
            ip.x < obstacles[i].x + obstacles[i].width &&
            ip.x + ip.width > obstacles[i].x &&
            ip.y < obstacles[i].y + obstacles[i].height &&
            ip.y + ip.height > obstacles[i].y) {
          gameOver = true;
        }
        if (obstacles[i].x + obstacles[i].width < 0) {
          obstacles.splice(i, 1);
          score += 10;
        }
      }
      
      for (let i = coins.length - 1; i >= 0; i--) {
        coins[i].update();
        coins[i].draw();
        if (coins[i].lane === activeDimension) {
          const ap = getActivePlayer();
          const dx = (ap.x + ap.width / 2) - coins[i].x;
          const dy = (ap.y + ap.height / 2) - coins[i].y;
          const dist = Math.hypot(dx, dy);
          if (dist < 30) {
            coins.splice(i, 1);
            score += 5;
            coinsCollected++;
            totalCoins++;
            coinSound.play();
          }
        }
        if (coins[i] && coins[i].x + 20 < 0) {
          coins.splice(i, 1);
        }
      }
      
      gameSpeed += 0.001;
      ctx.fillStyle = "#FFD700";
      ctx.font = "20px Merriweather";
      ctx.fillText("Score: " + score, 10, 30);
      ctx.fillText("Coins (Round): " + coinsCollected, 10, 60);
      ctx.fillText("Active Side: " + (activeDimension === 0 ? "Deva" : "Asura"), 10, 90);
    }
    
    function mainLoop(timestamp) {
      switch (currentScreen) {
        case "menu":
          drawMenu();
          break;
        case "options":
          drawOptions();
          break;
        case "shop":
          drawShop();
          break;
        case "game":
          drawGame(timestamp);
          break;
      }
      animationFrameId = requestAnimationFrame(mainLoop);
    }
    animationFrameId = requestAnimationFrame(mainLoop);
    
    canvas.addEventListener("click", function(evt) {
      const rect = canvas.getBoundingClientRect();
      const mx = evt.clientX - rect.left;
      const my = evt.clientY - rect.top;
      
      if (currentScreen === "menu") {
        if (mx >= currentMenuButtons.startBtn.x && mx <= currentMenuButtons.startBtn.x + currentMenuButtons.startBtn.w &&
            my >= currentMenuButtons.startBtn.y && my <= currentMenuButtons.startBtn.y + currentMenuButtons.startBtn.h) {
          startSound.play();
          initGame();
          isGameStarted = true;
          currentScreen = "game";
        } else if (mx >= currentMenuButtons.optionsBtn.x && mx <= currentMenuButtons.optionsBtn.x + currentMenuButtons.optionsBtn.w &&
                   my >= currentMenuButtons.optionsBtn.y && my <= currentMenuButtons.optionsBtn.y + currentMenuButtons.optionsBtn.h) {
          currentScreen = "options";
        } else if (mx >= currentMenuButtons.shopBtn.x && mx <= currentMenuButtons.shopBtn.x + currentMenuButtons.shopBtn.w &&
                   my >= currentMenuButtons.shopBtn.y && my <= currentMenuButtons.shopBtn.y + currentMenuButtons.shopBtn.h) {
          currentScreen = "shop";
        }
      } else if (currentScreen === "options") {
        if (mx >= currentOptionsButtons.volUp.x && mx <= currentOptionsButtons.volUp.x + currentOptionsButtons.volUp.w &&
            my >= currentOptionsButtons.volUp.y && my <= currentOptionsButtons.volUp.y + currentOptionsButtons.volUp.h) {
          startSound.volume = Math.min(1, startSound.volume + 0.1);
          coinSound.volume = Math.min(1, coinSound.volume + 0.1);
          gameOverSound.volume = Math.min(1, gameOverSound.volume + 0.1);
          jumpSound.volume = Math.min(1, jumpSound.volume + 0.1);
        } else if (mx >= currentOptionsButtons.volDown.x && mx <= currentOptionsButtons.volDown.x + currentOptionsButtons.volDown.w &&
                   my >= currentOptionsButtons.volDown.y && my <= currentOptionsButtons.volDown.y + currentOptionsButtons.volDown.h) {
          startSound.volume = Math.max(0, startSound.volume - 0.1);
          coinSound.volume = Math.max(0, coinSound.volume - 0.1);
          gameOverSound.volume = Math.max(0, gameOverSound.volume - 0.1);
          jumpSound.volume = Math.max(0, jumpSound.volume - 0.1);
        } else if (mx >= currentOptionsButtons.backBtn.x && mx <= currentOptionsButtons.backBtn.x + currentOptionsButtons.backBtn.w &&
                   my >= currentOptionsButtons.backBtn.y && my <= currentOptionsButtons.backBtn.y + currentOptionsButtons.backBtn.h) {
          currentScreen = "menu";
          menuAnimationTime = 0; // Reset title animation timer
        }
      } else if (currentScreen === "shop") {
        if (mx >= currentShopButtons.shopItem.x && mx <= currentShopButtons.shopItem.x + currentShopButtons.shopItem.w &&
            my >= currentShopButtons.shopItem.y && my <= currentShopButtons.shopItem.y + currentShopButtons.shopItem.h) {
          if (totalCoins >= 2 && !skinPurchased) {
            totalCoins -= 2;
            skinPurchased = true;
            activeSprite.src = "cv3.png";
            shopMessage = "Divine Attire Acquired!";
            notSound.play();
            setTimeout(() => { shopMessage = ""; }, 2000);
          } else if (skinPurchased) {
            shopMessage = "Divine Attire already acquired!";
            notSound.play();
            setTimeout(() => { shopMessage = ""; }, 2000);
          } else {
            shopMessage = "Not enough divine coins!";
            notSound.play();
            setTimeout(() => { shopMessage = ""; }, 2000);
          }
        } else if (mx >= currentShopButtons.backBtn.x && mx <= currentShopButtons.backBtn.x + currentShopButtons.backBtn.w &&
                   my >= currentShopButtons.backBtn.y && my <= currentShopButtons.backBtn.y + currentShopButtons.backBtn.h) {
          currentScreen = "menu";
          menuAnimationTime = 0;
        }
      } else if (currentScreen === "game") {
        if (gameOver) {
          highestScore = Math.max(highestScore, score);
          currentScreen = "menu";
          menuAnimationTime = 0;
        }
      }
    });
    
    window.addEventListener("keydown", function(e) {
      if (currentScreen === "game") {
        if ((e.code === "Space" || e.keyCode === 32) && !getActivePlayer().isJumping && isGameStarted) {
          getActivePlayer().yVelocity = getActivePlayer().jumpStrength;
          getActivePlayer().isJumping = true;
          jumpSound.play();
        }
        if (e.key === "d" || e.key === "D") {
          activeDimension = activeDimension === 0 ? 1 : 0;
        }
        if (e.key === "p" || e.key === "P") {
          paused = !paused;
        }
        if (e.key === "r" || e.key === "R") {
          initGame();
          isGameStarted = true;
        }
      }
    });
    
  </script>
</body>
</html>
